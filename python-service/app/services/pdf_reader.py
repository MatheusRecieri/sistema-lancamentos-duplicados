import re
from typing import List, Dict, Any, Optional
import pdfplumber
from datetime import datetime
from app.utils.normalizer import (
    normalize_text,
    clean_monetary_value,
    clean_date,
    clean_supplier_name,
)


class PDFReader:
    """
    Leitor de PDF robusto para m√∫tiplas estrategias de extra√ß√£o
    """

    def __init__(self):
        self.extraction_strategies = [
            self._extract_with_layout,
            self._extract_with_table,
            self._extract_with_regex,
        ]

    def extract_raw_text(self, pdf_path: str) -> str:
        # extrai o texto brutodo pdf para debug

        with pdfplumber.open(pdf_path) as pdf:
            text = ""
            for page in pdf.pages:
                text += page.extract_text() or ""

            return text

    def extract_from_pdf(self, pdf_path: str) -> List[Dict[str, Any]]:
        """
        Extrai dados estruturados do PDF usando m√∫ltiplas estrat√©gias

        Args:
            pdf_path: Caminho do arquivo PDF

        Returns:
            Lista de dicion√°rios com dados extra√≠dos
        """
        print(f"üîç Iniciando extra√ß√£o do PDF: {pdf_path}")

        with pdfplumber.open(pdf_path) as pdf:
            all_entries = []

            for page_num, page in enumerate(pdf.pages, 1):
                print(f"üìÑ Processando p√°gina {page_num}/{len(pdf.pages)}")

                # Tenta cada estrat√©gia at√© uma funcionar
                for strategy in self.extraction_strategies:
                    entries = strategy(page, page_num)
                    if entries:
                        print(
                            f"   ‚úÖ Estrat√©gia {strategy.__name__} encontrou {len(entries)} entradas"
                        )
                        all_entries.extend(entries)
                        break
                else:
                    print(f"   ‚ö†Ô∏è Nenhuma estrat√©gia funcionou na p√°gina {page_num}")

            print(f"üéØ Total extra√≠do: {len(all_entries)} registros")
            return all_entries

    def _extract_with_layout(self, page, page_num: int) -> List[Dict[str, Any]]:
        """
        Extart√©gia 1: Extra√ß√£o baseada em layout preservado
        Otimizada para formato ACOMPANHAMENTO DE ENTRADAS
        """

        text = page.extract_text(layout=True)
        if not text:
            return []

        entries = []
        lines = text.split("\n")

        # Detecta onde os dados come√ßam

        data_start_idx = -1
        for idx, line in enumerate(lines):
            # proucura pela linha de cabe√ßalho das colunas
            if "Codigo" in line and "Data" in line and "Nota" in line:
                data_start_idx = idx + 1
                print(f"Cabe√ßalho encontrado na linha {idx}")
                break

        if data_start_idx == -1:
            data_start_idx = 10  # fallback: pula primeiras 10 linhas

        for idx in range(data_start_idx, len(lines)):
            line = lines[idx]

            if not line.strip() or len(line.strip()) < 20:
                continue

            if self._is_total_or_footer(line):
                break

            if self._is_tax_subline(line):
                continue

            entry = self._parse_structured_line(line, idx, page_num)
            if entry and self._is_valid_entry(entry):
                entries.append(entry)

        return entries

    def _extract_with_table(self, page, pge_num) -> List[Dict[str, Any]]:
        """
        Estrategia 2: Extra√ß√£o de tabelas
        Melhor para pedf com estrutura tabular clara
        """

        tables = page.extract_tables()
        if not tables:
            return []

        entries = []

        for table in tables:
            if not tables or len(table) < 2:
                continue

            header = table[0]

            col_map = self.map_columns(header)

            for row_idx, row in enumerate(table[1:], 1):
                if note_row or len(row) < 3:
                    continue

                entry = self._parse_table_row(row, col_map, row_idx, page_num)
                if entry and self._is_valid_entry(entry):
                    entries.append(entry)

        return entries

    def _extract_with_regex(self, page, page_num: int) -> List[Dict[str, Any]]:
        """
        Estrat√©gia 3: Extra√ß√£o via regex
        Fallback para PDFs sem estrutura clara
        """
        text = page.extract_text()
        if not text:
            return []

        entries = []
        lines = text.split("\n")

        # Padr√µes de extra√ß√£o
        patterns = [
            # Padr√£o completo: C√ìDIGO DATA NOTA FORNECEDOR VALOR_CONTABIL VALOR
            r"(\d{3,6})\s+(\d{2}/\d{2}/\d{2,4})\s+(\d+)\s+(.+?)\s+([\d.,]+)\s+([\d.,]+)",
            # Padr√£o sem c√≥digo: DATA NOTA FORNECEDOR VALOR
            r"(\d{2}/\d{2}/\d{2,4})\s+(\d+)\s+(.{10,}?)\s+([\d.,]+)",
            # Padr√£o minimalista: FORNECEDOR DATA VALOR
            r"([A-Z][A-Za-z\s]{5,50}?)\s+(\d{2}/\d{2}/\d{2,4})\s+([\d.,]+)",
        ]

        for idx, line in enumerate(lines):
            if self._is_non_data_line(line):
                continue

            for pattern in patterns:
                match = re.search(pattern, line)
                if match:
                    entry = self._build_entry_from_regex(
                        match, pattern, line, idx, page_num
                    )
                    if entry and self._is_valid_entry(entry):
                        entries.append(entry)
                        break

        return entries

    def _find_header_line(self, lines: List[str]) -> int:
        """Encontra a linha do cabe√ßalho"""
        header_patterns = [
            r"c√≥digo.*fornecedor.*data.*nota.*valor",
            r"supplier.*date.*invoice.*amount",
            r"cod.*forn.*dt.*vl",
        ]

        for idx, line in enumerate(lines[:15]):  # Procura nas primeiras 15 linhas
            line_lower = line.lower()
            for pattern in header_patterns:
                if re.search(pattern, line_lower, re.IGNORECASE):
                    return idx

        return -1

    def _is_non_data_line(self, line: str) -> bool:
        """Identifica linhas que n√£o s√£o dados"""
        non_data_patterns = [
            r"^total",
            r"^subtotal",
            r"^p√°gina",
            r"^emiss√£o",
            r"sistema licenciado",
            r"^cnpj:",
            r"^insc\s+est:",
            r"acompanhamento\s+de",
            r"^\s*$",  # Linha vazia
        ]

        line_lower = line.lower().strip()
        return any(re.match(pattern, line_lower) for pattern in non_data_patterns)

    def _is_tax_subline(self, line: str) -> bool:
        """Identifica linhas de sub-impostos que n√£o s√£o notas"""
        line_clean = line.strip()

        # Padr√µes de linhas de imposto
        tax_patterns = [
            r"^\s*ISS\s+",
            r"^\s*IRRF\s+",
            r"^\s*CRF\s+",
            r"^\s*INSS-RET\s+",
            r"^\s*ISS RET\.\s+",
        ]

        return any(
            re.match(pattern, line_clean, re.IGNORECASE) for pattern in tax_patterns
        )

    def _is_total_or_footer(self, line: str) -> bool:
        """Identifica linhas de total e rodap√©"""
        line_lower = line.lower().strip()

        footer_patterns = [
            "total cfop",
            "total geral",
            "sistema licenciado",
            "p√°gina:",
        ]

        return any(pattern in line_lower for pattern in footer_patterns)

    def _parse_structured_line(
        self, line: str, line_num: int, page_num: int
    ) -> Optional[Dict[str, Any]]:
        """
        Parse especializado para formato ACOMPANHAMENTO DE ENTRADAS
        Formato esperado: C√≥digo | Data | Nota | S√©rie | ... | Fornecedor | ... | Valor Cont√°bil
        """
        # Remove espa√ßos extras
        parts = line.split()

        if len(parts) < 8:
            return None

        try:
            # Extra√ß√£o de campos fixos
            codigo = parts[0]

            # Procura pela data (formato DD/MM/YYYY)
            data_idx = -1
            for i, part in enumerate(parts):
                if re.match(r"\d{2}/\d{2}/\d{4}", part):
                    data_idx = i
                    break

            if data_idx == -1:
                return None

            data = parts[data_idx]

            # Nota fiscal geralmente vem depois da data
            nota = parts[data_idx + 1] if data_idx + 1 < len(parts) else "N/A"

            # Procura pelo valor cont√°bil (√∫ltimo valor antes dos impostos)
            # Formato: 1.234,56 ou 234,56
            valor_contabil = "0,00"
            for i in range(len(parts) - 1, -1, -1):
                if re.match(r"[\d.,]+", parts[i]) and "," in parts[i]:
                    valor_contabil = parts[i]
                    break

            # Fornecedor est√° entre a s√©rie/esp√©cie e o CFOP
            # Geralmente ap√≥s o 5¬∫ elemento at√© antes do valor
            fornecedor_parts = []
            in_fornecedor = False

            for i in range(data_idx + 3, len(parts)):
                part = parts[i]

                # Para quando encontrar padr√µes de fim de fornecedor
                if re.match(r"\d-\d+", part):  # CFOP (ex: 1-933)
                    break

                # Pula campos num√©ricos curtos (s√©rie, esp√©cie)
                if i <= data_idx + 5 and part.isdigit() and len(part) <= 2:
                    continue

                # Adiciona ao fornecedor
                if not part.replace(".", "").replace(",", "").isdigit():
                    fornecedor_parts.append(part)

            fornecedor = (
                " ".join(fornecedor_parts)
                if fornecedor_parts
                else "Fornecedor Desconhecido"
            )

            return {
                "codigoFornecedor": codigo.strip(),
                "fornecedor": clean_supplier_name(fornecedor),
                "data": clean_date(data),
                "notaSerie": nota.strip(),
                "valorContabil": clean_monetary_value(valor_contabil),
                "valor": clean_monetary_value(valor_contabil),
                "posicao": f"P√°g {page_num}, Linha {line_num}",
            }

        except Exception as e:
            # Se falhar, n√£o retorna nada
            return None

    def _map_columns(self, header: List[str]) -> Dict[str, int]:
        """Mapeia colunas da tabela"""
        col_map = {}

        for idx, col in enumerate(header):
            if not col:
                continue

            col_lower = col.lower()

            if "c√≥digo" in col_lower or "codigo" in col_lower:
                col_map["codigo"] = idx
            elif "fornecedor" in col_lower or "supplier" in col_lower:
                col_map["fornecedor"] = idx
            elif "data" in col_lower or "date" in col_lower:
                col_map["data"] = idx
            elif "nota" in col_lower or "invoice" in col_lower or "nf" in col_lower:
                col_map["nota"] = idx
            elif "cont√°bil" in col_lower or "contabil" in col_lower:
                col_map["valor_contabil"] = idx
            elif "valor" in col_lower or "amount" in col_lower:
                if "valor_contabil" not in col_map:
                    col_map["valor"] = idx

        return col_map

    def _parse_table_row(
        self, row: List[str], col_map: Dict[str, int], row_num: int, page_num: int
    ) -> Optional[Dict[str, Any]]:
        """Parse linha de tabela"""

        def get_col(key: str, default: str = "") -> str:
            idx = col_map.get(key, -1)
            if idx != -1 and idx < len(row):
                return str(row[idx] or default).strip()
            return default

        fornecedor = get_col("fornecedor", "Desconhecido")
        data = get_col("data")
        valor_contabil = get_col("valor_contabil", get_col("valor", "0,00"))

        # Valida√ß√£o b√°sica
        if not fornecedor or not data or fornecedor == "Desconhecido":
            return None

        return {
            "codigoFornecedor": get_col("codigo", "N/A"),
            "fornecedor": fornecedor,
            "data": clean_date(data),
            "notaSerie": get_col("nota", "N/A"),
            "valorContabil": clean_monetary_value(valor_contabil),
            "valor": clean_monetary_value(get_col("valor", valor_contabil)),
            "posicao": f"P√°g {page_num}, Linha {row_num}",
        }

    def _build_entry_from_regex(
        self, match, pattern: str, original_line: str, line_num: int, page_num: int
    ) -> Optional[Dict[str, Any]]:
        """Constr√≥i entrada a partir de match regex"""
        groups = match.groups()

        # Identifica qual padr√£o foi usado pelo n√∫mero de grupos
        if len(groups) >= 6:  # Padr√£o completo
            codigo, data, nota, fornecedor, valor_contabil, valor = groups
        elif len(groups) == 4:  # Sem c√≥digo
            data, nota, fornecedor, valor_contabil = groups
            codigo = "N/A"
            valor = valor_contabil
        elif len(groups) == 3:  # Minimalista
            fornecedor, data, valor_contabil = groups
            codigo = "N/A"
            nota = "N/A"
            valor = valor_contabil
        else:
            return None

        return {
            "codigoFornecedor": str(codigo).strip(),
            "fornecedor": fornecedor.strip(),
            "data": clean_date(data),
            "notaSerie": str(nota).strip(),
            "valorContabil": clean_monetary_value(valor_contabil),
            "valor": clean_monetary_value(valor),
            "posicao": f"P√°g {page_num}, Linha {line_num}",
        }

    def _is_valid_entry(self, entry: Dict[str, Any]) -> bool:
        """Valida se a entrada √© v√°lida"""
        if not entry:
            return False

        # Valida√ß√µes essenciais
        if not entry.get("fornecedor") or entry["fornecedor"] == "Desconhecido":
            return False

        if not entry.get("data") or entry["data"] == "":
            return False

        if entry.get("valorContabil", "0,00") == "0,00":
            return False

        # Valida se fornecedor tem comprimento razo√°vel
        if len(entry["fornecedor"]) < 3:
            return False

        return True
